# Скраппер маршрутов общественного транспорта Белграда
---

## Описание и способы использования.

По [данному адресу](https://www.bgprevoz.rs/linije/red-voznje) находится страница выбора одного из приблизительно 450 маршрутов общественного транспорта, курсирующего по Белграду. После выбора одного из них происходит переход на страницу с расписанием для указанного маршрута.

Каждая страница обычно представляет собой две таблицы - по одной для каждой конечной станции, с указанием времени отправки транспорта с указанной станции. Встречаются маршруты, где конечная станция одна.

Скраппер способен собрать ссылки на маршруты с указанной страницы и собрать информацию о маршрутах как по всем ссылкам, так и по произвольному числу ссылок.

### Скраппер представляет собой экземпляр класса _RoutesScrapper_, который имеет следующие основные методы:

- _change_to_latin()_. По-умолчанию сайт использует кириллический алфавит сербского языка, но есть возможность использования латиницы. Данный метод сообщает серверу, что в рамках текущей сессии пользователь предпочитает использовать латинский алфавит;
- _change_to_cyrillic()_. Все то же самое, только переключение на кириллический алфавит.
- _collect_links_to_crawl(path, content_tag=True, attr=None, value=None, clear_from_pdf=True)_. Метод собирает ссылки со страницы _path_ для последующего прохода и исследования. Поскольку при создании экземпляра класса необходимо передать ему корневой адрес сайта, в рамках которого происходит работа скраппера, метод принимает в качестве аргумента относительный путь к странице, на которой необходимо собрать ссылки, впрочем, передача абсолютного url-адреса страницы также не вызовет ошибку. Также по-умолчанию метод собрает все абсолютные ссылки, которые встречаются на странице, однако есть возможность сужения области поиска путем передачи аргументов _content_tag_ - имени тега, содержащего в себе или тегах-наследниках искомые ссылки, _attr_ - аттрибут тега, содержащего ссылку, и _value_ - значение указанного аттрибута. 

	Допустим, страница имеет следующий код.
	```html
	<!doctype html>
	<html lang="sr-Cyrl-RS">
	<head>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1">
    	<meta name="description" content="Секретаријат за јавни превоз">
    	<meta name="keywords" content="javni prevoz">
    	<meta name="author" content="Zorana Ranković">
    	<meta name="csrf-token" content="zadq44Rj3GQ9gy3fjLJ8m0rj3JYKrkZYtDAUJDED">
    	<title>Секретаријат за јавни превоз | Ред вожње</title>
    	<link rel="shortcut icon" type="image/png" href="https://www.bgprevoz.rs/images/logo.png" sizes="32x32">
    	<link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300&amp;family=Roboto:wght@400;700&amp;display=swap" rel="stylesheet">
    	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    	<link rel="stylesheet" href="https://www.bgprevoz.rs/css/fontello.css">
    	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tw-elements/dist/css/index.min.css" />
    	<link rel="stylesheet" href="https://www.bgprevoz.rs/css/app.css">
  		<link rel="stylesheet" href="https://www.bgprevoz.rs/css/web.css">
  		<link rel="stylesheet" href="https://www.bgprevoz.rs/css/rezimske-izmene-admin-responsive.css">
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="..." crossorigin=""/>
		<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="..." crossorigin=""></script>
	</head>
	<body>...</body>
	</html>
	```

	Здесь достаточно много тегов _link_, имеющих аттрибут _rel_ со значением _stylesheet_. Для их сбора вызов метода может выглядеть следующим образом:
	
	```python
	crawler = BelgradTrasnportCrawler("https://www.bgprevoz.rs/", headers={})

    stylesheet_links = crawler.collect_links_to_crawl(
        "/linije/red-voznje", "link", "rel", "stylesheet"
    )
    print(stylesheet_links) 
    # {'https://www.bgprevoz.rs/css/select2.min.css', 
    #  'https://www.bgprevoz.rs/css/app.css', 
    #  'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css', 
    #  'https://www.bgprevoz.rs/css/fontello.css', 
    #  'https://cdn.jsdelivr.net/npm/tw-elements/dist/css/index.min.css',
    #  'https://fonts.googleapis.com/icon?family=Material+Icons',
    #  'https://www.bgprevoz.rs/css/rezimske-izmene-admin-responsive.css',
    #  'https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300&family=Roboto:wght@400;700&display=swap',
    #  'https://www.bgprevoz.rs/css/web.css',
    #  'https://unpkg.com/leaflet@1.7.1/dist/leaflet.css'}
    ```
	Как видно из вывода значения переменной _stylesheet_links_, метод возвращает __множество__ (set) ссылок, что гарантирует отсутствие среди них дубликатов одного и того же адреса.
	
	Параметр _clean_from_pdf_ по-умолчанию имеет значение _True_ и предназначен для исключения сбора ссылок на страницы расписания, представленные в виде документа в формате *.pdf.
	
- _parse_route(link)_. Метод принимает url-адрес страницы с расписанием, и возвращает экземпляр класса _BelgradRoute_ (о нем немного позднее).

- _parse_all_routes(path=None, direct_links=None, clear_from_pdf=True)_. Метод принимает либо путь к странице, откуда нужно собрать ссылки на страницы, с которых, в свою очередь, будут собраны данные о маршрутах, либо готовый список адресов, которые будут переданы в метод _parse_route()_. Так же, как и в методе _collect_links_to_crawl()_, есть параметр _clear_from_pdf_ со значением по-умолчанию _True_. Передача в метод и пути к странице, и списка ссылок либо отсутствие хотя бы одного из указанных аргументов приведет к поднятию исключения.

### Класс _BelgradRoute_ представляет собой класс маршрута, содержащего данные о времени отправления общественного транспорта как минимум с одной из станций на маршруте.

Данный класс имеет следующие аттрибуты и методы (все атрибуты будут продемонстрированы на примере [этого](https://www.bgprevoz.rs/linije/red-voznje/linija/2/prikaz) маршрута):

- _route_name_. Имя маршрута, например: 
	>  Red vožnje linija 2
- _description_. Название конечных точек маршрута:
	> Unutrašnji Krug - Spoljašnji Krug
- _first_station_. Имя первой станции маршрута:
	> Unutrašnji Krug
- _last_station_. Имя второй станции маршрута (при наличии):
	> Spoljašnji Krug
- _first_st_dep_. Время отправления с первой станции маршрута по дням недели[^1]:
	```python
	{
	'Radni dan': ['04:10', '04:35', '04:55', '05:10'...], 
	'Subota': ['04:10', '04:35', '04:55', '05:10'...],
	'Nedelja': ['04:10', '04:35', '04:55', '05:10'...]
	}
	```
- _last_st_dep_. Аналогично для второй станции маршрута.
- _stations_. Названия обеих станций маршрута в виде списка.

Ранее уже упоминалось, что в Белграде встречаются маршруты из одной станции, [например](https://www.bgprevoz.rs/linije/red-voznje/linija/60316/prikaz), в таком случае атрибуты, касающиеся второй станции, будут иметь значение _None_.

- _get_dict()_. Возвращает словарь python с информацией о маршруте, все данные берутся из соответствующих аттрибутов класса:
	```python
	{
        "route_name": route_name,
        "route_description": description,
        "first_station": {
        		"name": first_station, 
        		"departures": first_st_dep},
        "last_station": {
        		"name": last_station,
        		"departures": last_st_dep},
        }
	```
- _get_station_csv(station, path, mode="w")_. Метод принимает регистронезависимое название одной из станций маршрута и записывает название станции расписание отправки транспорта с нее в таблицу формата *.csv по переданному пользователем в виде второго позиционного аргумента пути:
	```csv
	Spoljašnji Krug

	Radni dan,Subota,Nedelja
	04:10,04:10,04:10
	04:35,04:35,04:35
	04:55,04:55,04:55
	05:10,05:15,05:15...
	```
	По-умолчанию метод записи в файл выбран __"w"__, то есть каждый последующий вызов метода будет перезаписывать файл с таким же названием, но можно указать и __"a"__.
- _get_route_csv(path)_. Записывает в csv-таблицу название всего маршрута и расписание для обеих станций (при наличии).


[^1]: Если быть точным, то расписание делится на группы "По рабочим дням", "По субботам" и "По воскресеньям".

## Тестирование
Необходимость упоминания тестов в этом README обусловлена спецификой данных, которые собирает скраппер.

Для тестов подготовлены отдельные файлы, которые содержат ссылки, собранные с оригинальной страницы выбора маршрута, как те, которые не ведут на pdf-файлы с расписанием, так и отдельно список ссылок на такие файлы. Также собраны ссылки на таблицы стилей для тестирования корректности сбора ссылок с конкретными атрибутами и их значениями.

То есть, нетрудно понять, что тестирование из файла __test_live_serbian_scrapper.py__ проводится на _"живом"_ сайте, находящемся в сети Интернет: собираем данные с сайта, сравниваем их с эталонными значениями, если совпали - тест пройден.

При этом данные о времени отправления могут меняться в силу объективных причин, и тестовые данные уже не в полной мере будут соответствовать настоящим данным, хранящимся на сервере.

По указанной причине для обеспечения полноты тестирования подготовлен локальный веб-сервер на Flask, который запускается из __synthetic_server.py__, и который отдает 12 полноценных тестовых страниц, сохранивших оригинальные данные о времени отправления транспорта и всю html-разметку.

Таким образом, тесты в файле __test_synthetic_serbian_scrapper.py__ в целом аналогичны таковым из __test_live_serbian_scrapper.py__, однако в нем отсутствуют тесты:  
- на переключение алфавита с латинского на кириллический и обратно - данная опция в целом работает для всего сайта и никак не связана с расписанием. Если тесты функциональности этих методов будут провалены, очевидно, необходимо менять код скраппера в связи с изменением разметки сайта;
- на сбор ссылок на таблицы стилей - поскольку теперь таблицы стилей имеют относительный адрес на локальном сервере вместо абсолютного, ведущего на удаленный сервер, изменение кода этого теста также теряет смысл. Во всяком случае работоспособность метода проверяется путем сбора абсолютных ссылок на страницы с маршрутами на специально поднятой для этих целей локальной копии стартовой страницы.

Для развертывания виртуального окружения и менеджмента зависимостей использовался Poetry, список зависимостей приведен как в _pyproject.toml_, так и в специально созданном для преданных __virtualenv__ пользователей _requirements.txt_. 